https://github.com/cmjones/jos-mmap/edit/master/answers-lab2.txt#L38

Challenge: Bouncing Kernel

In order to switch from user mode to kernel mode, user code calls the 'int' instruction.  This
instruction provides a controlled way to change the CPL and jump to a fixed point in memory
depending on the interrupt.  There are 256 such interrupts, with each interrupt descriptor using
8-bytes.  Thus, the total memory for this table is 2kb.  Easily fit on a single 4kb page.

SMALL WINDOW WITH KERNEL RW, USER - PERMISSION
A neat way to allow the user access to the entire 4gb virtual address range, then, is to save just
one page in one page table (one page directory entry) for holding the IDT.  This page should also
hold kernel code for the IDT to point to, and the page should be RW only by the kernel (CPL 3).
This provides a small window into the kernel accessible from user space.  There would have to be
another page for the process's page directory, and possibly a small number of other pages.  These
all together form the "window."

MOVING THE WINDOW
The neat thing is that this window can float anywhere in the virtual space.  When it changes location,
The IDT needs to update so that each descriptor points to the correct point in the window's new
location, and that new IDT needs to be loaded.  If the user tries to allocate/access the window,
a permission fault will be generated by the hardware.  The kernel should then change the mapping of
the IDT to some different free page in virtual space, then allocate/access the page as normal.

TRANSFERRING FROM USER MODE TO KERNEL MODE
Each process could have its own page directory, each which address the full 4GB of virtual space.
Interestingly, the window could be in a different virtual space for each process.  When a process
tries to enter kernel mode to perform a system call or handle a device interrupt, a number of things
need to happen:

1. The processor looks up the interrupt in the current location of the IDT, finds the entry point
into the kernel located in that page, and goes to that entry point.

2. At the entry point, the kernel caches the PTE of virtual address 0xF0000000, and maps the IDT
page to virtual address 0xF0000000.  (0xF0000000 is arbitrary, this is just a fixed point in
physical memory where the IDT page actually lies)

3. The processor jumps to address 0xF0000000+OFFSET, where OFFSET is the offset into the current
page of the next instruction.

4. Now running with EIP in the 0xF0000000 page, swap out the page directory to the kernel page
directory, which contains all the mappings the kernel needs in an address space of 4GB and is
located in a fixed physical address.

5. Continue with whatever interrupt was called.

TRANSFERRING FROM KERNEL MODE TO USER MODE
After the interrupt is handled and the kernel wants to return back to user mode, the following needs
to happen:

1. The processor decides which process to execute next, and figures out where the IDT page in that
user's address space is located.

2. The processor loads the IDT page into the kernel page directory, in the same location as in the
user process's directory.

3. The processor then jumps to that IDT page, and swaps page directories back to the user process's.

4. Clean up the kernel page directory (restore the mapping where the IDT page was placed in the
kernel page directory), then jump back to user code.

The upshot of these two sequences is that user mode contains user mappings and a single kernel page,
while kernel mode contains a full address space of kernel mappings.  The kernel should have each
user's page directory accessible, and can access the user address space by temporarily copying user
virtual address mappings to the kernel's page directory.

Throughout this description, I described the IDT and related code as fitting on a single virtual
page.  If the "window" code is larger than a page, then more can be used.  There would simply be
more addresses that would have to move around when the user tries to access them.

It should be possible, therefore, to have some small number of pages K, such that the user can
allocate up to 2^20-K pages before running out of virtual address space.  But those K pages don't
exist in any fixed space, even though they would be fixed by in physical memory.  Chances are the
system would run out of memory long before those 2^20-K pages are allocated anyway, with multiple
processes running and physical memory required for the kernel, data-structures, and page directories.

PHYSICAL ADDRESSING
Conveniently, since the kernel has access to a full 4GB of virtual address space, the kernel page
directory can be mapped 1-to-1 with physical address space similar to the mappings of the high
addresses in JOS.  This allows very simple physical addressing.  The same mechanism also allows for
easy device access.  Since the kernel must access devices anyway, any part of the 4GB space may be
used for devices.

ADVANTAGES
The advantages for building the kernel this way are mainly in opening the full 4GB of address space
to user processes.  Processes can thus allocate that 4GB however they want, and they will only very
rarely run into a permissions fault.  The kernel has its own 4GB of address space as well, so there
is fairly little to limit where in memory the kernel is placed.  With more address space comes
more flexibility for both user processes and kernel processes, though the whole system is still
limited to a total of 4GB of physical memory.

There may actually be a decrease in some parts of the kernel from having a dedicated virtual
kernel space.  The most complex portion of the kernel is switching between modes (which boils down
to tricky switching of the page descriptor table), and dynamic mapping to access the user address
space.  Every other aspect of the kernel stays pretty much the same (physical page allocation is
pretty much the same as before), and some even become simpler (physical addressing is trivial with
a 1-to-1 mapping, though some care needs to be used when parts of the user address space is brought
in).  IO devices can be mapped just as before.

DISADVANTAGES
The biggest disadvantages for the kernel are in speed and in complexity.  Interrupts become quite
slow, since a fair amount of shuffling has to be performed in order to switch descriptor tables
cleanly.  With interrupts that can happen very frequently, like clock ticks, this might be the
biggest detriment.

There's also a slowdown in accessing user memory, since mappings must be temporarily made into the
kernel's directory before they can be accessed, and those mappings need to be restored once the
kernel is done with them.  The good news is that these mappings can occur in a dedicated section of
memory, and can be changed dynamically as needed.  There is probably a clever way to manipulate these
mappings in a dedicated section of the kernel, but it would have to take into account the fact that
multiple processors could be in kernel mode simultaneously.

OTHER FACTORS
I'd actually be interested in creating a kernel like this.  The complexity of managing the small
window through which the kernel is accessed seems to be constrained to a relatively small portion
of the kernel code, with the possible benefit of simpler memory layouts.  The biggest detriment
seems to be the cost of device interrupts, which could be a real killer at 100s of interrupts a
second, each of which flushes the TLB multiple times.  Where it gains, though, is in an extremely
clear isolation of kernel memory and user memory, and I find the idea of switching out PDTs to be
rather neat.  The loss of distinction between physical and virtual address in the kernel also would
remove the tedium of keeping track of which address you're dealing with at the moment.

A bunch of UNIX-style conventions should still work with the bouncing kernel as well.  To fork a
process, just copy the descriptor table into a new table.  You could mark each entry as "copied" so
if the process decides to write to a writable page, that page is copied into a newly allocated page,
remapped, and written to.  There's no need to copy kernel mappings as with JOS, since the kernel
page directory is separate from the process's page directory.  Threads, I suppose, would simply
be processes that operate with the same page tables.
